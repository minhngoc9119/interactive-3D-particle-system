<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Christmas Particle Experience</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* Deep dark night */
            font-family: 'Courier New', Courier, monospace;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Minimalistic UI Overlay */
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            color: white;
            pointer-events: none; /* Let clicks pass through to 3D scene */
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        p {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }

        /* Loading indicator */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 20;
            font-size: 24px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader">Loading Magic...</div>

    <div id="ui">
        <h1>Holiday Particles</h1>
        <p>Scroll to Zoom • Click to Burst • Move to Interact</p>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- CONFIGURATION ---
        const config = {
            particleCount: 20000,
            particleSize: 0.15,
            color: '#ff2244', // Initial Red
            secondaryColor: '#ffffff',
            preset: 'Tree', // Options: Snow, Tree, Galaxy
            speed: 1.0,
            hoverRadius: 3.0,
            repelStrength: 2.0, // Interaction strength
            bloomStrength: 1.5,
            bloomRadius: 0.4,
            bloomThreshold: 0.1
        };

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02); // Distance fog for depth

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 2, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.maxDistance = 20;
        controls.minDistance = 2;

        // --- SHADERS (GLSL) ---
        
        // 1. Vertex Shader: Handles position, movement, and mouse interaction
        const vertexShader = `
            uniform float uTime;
            uniform float uSize;
            uniform vec3 uMouse;
            uniform float uHoverRadius;
            uniform float uRepelStrength;
            
            attribute vec3 aRandomness;
            attribute float aScale;
            
            varying vec3 vColor;
            varying float vDistance;

            void main() {
                vec3 pos = position;

                // Adds a gentle "breathing" / falling animation
                // We use the randomness attribute so particles don't move in unison
                float time = uTime * 0.5;
                
                // Add subtle organic noise movement
                pos.x += sin(time + aRandomness.x * 10.0) * 0.1;
                pos.y += cos(time + aRandomness.y * 10.0) * 0.1;
                pos.z += sin(time + aRandomness.z * 10.0) * 0.1;

                // --- MOUSE INTERACTION MATH ---
                float dist = distance(pos, uMouse);
                if (dist < uHoverRadius) {
                    vec3 dir = normalize(pos - uMouse);
                    float force = (uHoverRadius - dist) / uHoverRadius;
                    
                    // Repel particles smoothly
                    pos += dir * force * uRepelStrength;
                }

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation: Particles are smaller when further away
                gl_PointSize = uSize * aScale * (300.0 / -mvPosition.z);
                
                // Pass distance to fragment shader for depth effects
                vDistance = -mvPosition.z;
            }
        `;

        // 2. Fragment Shader: Handles the look (glow, shape, color)
        const fragmentShader = `
            uniform vec3 uColor;
            uniform vec3 uColor2;
            
            void main() {
                // Create a soft circular glow instead of a square pixel
                float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
                float strength = 0.05 / distanceToCenter - 0.1;
                
                // Discard pixels outside the circle
                if(distanceToCenter > 0.5) discard;

                // Mix colors for variety
                vec3 finalColor = mix(uColor, uColor2, strength * 2.0);

                gl_FragColor = vec4(finalColor, strength);
            }
        `;

        // --- PARTICLE SYSTEM ---
        let geometry = null;
        let material = null;
        let points = null;

        function createParticles() {
            if (points) {
                geometry.dispose();
                material.dispose();
                scene.remove(points);
            }

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const randomness = new Float32Array(config.particleCount * 3);
            const scales = new Float32Array(config.particleCount);

            // Generate Shapes based on Presets
            for (let i = 0; i < config.particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;

                if (config.preset === 'Snowfall') {
                    // Random box distribution
                    x = (Math.random() - 0.5) * 20;
                    y = (Math.random() - 0.5) * 20;
                    z = (Math.random() - 0.5) * 20;
                } 
                else if (config.preset === 'Tree') {
                    // Conical Spiral Math
                    const turn = i / config.particleCount * 25.0; // How many turns
                    const h = i / config.particleCount * 10.0 - 5.0; // Height -5 to 5
                    const r = (1.0 - (h + 5.0) / 10.0) * 3.5; // Radius decreases as height increases
                    
                    x = Math.cos(turn * Math.PI * 2) * r;
                    z = Math.sin(turn * Math.PI * 2) * r;
                    y = h;
                    
                    // Add some "jitter" so it looks like pine needles/ornaments, not a perfect line
                    x += (Math.random() - 0.5) * 0.5;
                    z += (Math.random() - 0.5) * 0.5;
                    y += (Math.random() - 0.5) * 0.5;
                }
                else if (config.preset === 'Galaxy') {
                    // Flattened sphere
                    const radius = Math.random() * 8;
                    const spinAngle = radius * 0.5;
                    const branchAngle = (i % 3) * ((Math.PI * 2) / 3);
                    
                    const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1); 
                    const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);
                    const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);

                    x = Math.cos(branchAngle + spinAngle) * radius + randomX;
                    y = randomY * 2.0;
                    z = Math.sin(branchAngle + spinAngle) * radius + randomZ;
                }

                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;

                randomness[i3] = Math.random();
                randomness[i3 + 1] = Math.random();
                randomness[i3 + 2] = Math.random();
                
                scales[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aRandomness', new THREE.BufferAttribute(randomness, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));

            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uSize: { value: config.particleSize * renderer.getPixelRatio() },
                    uColor: { value: new THREE.Color(config.color) },
                    uColor2: { value: new THREE.Color(config.secondaryColor) },
                    uMouse: { value: new THREE.Vector3(999, 999, 999) }, // Init off-screen
                    uHoverRadius: { value: config.hoverRadius },
                    uRepelStrength: { value: config.repelStrength }
                },
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: false,
                transparent: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        createParticles();

        // --- POST PROCESSING (BLOOM) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            config.bloomStrength,
            config.bloomRadius,
            config.bloomThreshold
        );

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- MOUSE RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Invisible plane facing camera
        const targetMousePos = new THREE.Vector3();

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Project ray from camera to invisible plane to get 3D coords
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, targetMousePos);
            
            // Send position to shader
            if(material) {
                material.uniforms.uMouse.value.copy(targetMousePos);
            }
        });

        // Click interaction: Burst Effect
        window.addEventListener('click', () => {
            // Simple manual animation logic (expanding and contracting radius)
            let start = Date.now();
            let duration = 300; // ms
            let initialRadius = config.hoverRadius;
            let maxRadius = 10.0;

            function animateBurst() {
                let now = Date.now();
                let progress = (now - start) / duration;
                
                if (progress < 1) {
                    // Ping pong effect (expand then contract)
                    let val = Math.sin(progress * Math.PI) * maxRadius;
                    if (material) {
                        material.uniforms.uHoverRadius.value = initialRadius + val;
                        material.uniforms.uRepelStrength.value = config.repelStrength * 5.0; // Stronger push
                    }
                    requestAnimationFrame(animateBurst);
                } else {
                    // Reset
                    if (material) {
                        material.uniforms.uHoverRadius.value = initialRadius;
                        material.uniforms.uRepelStrength.value = config.repelStrength;
                    }
                }
            }
            animateBurst();
        });

        // --- UI PANEL ---
        const gui = new GUI({ title: 'Christmas Settings' });
        
        gui.add(config, 'preset', ['Snowfall', 'Tree', 'Galaxy']).name('Scene Preset').onChange(createParticles);
        
        const folderVisuals = gui.addFolder('Visuals');
        folderVisuals.addColor(config, 'color').name('Primary Color').onChange((v) => { material.uniforms.uColor.value.set(v); });
        folderVisuals.addColor(config, 'secondaryColor').name('Glow Color').onChange((v) => { material.uniforms.uColor2.value.set(v); });
        folderVisuals.add(config, 'particleSize', 0.01, 1.0).name('Particle Size').onChange((v) => { material.uniforms.uSize.value = v * renderer.getPixelRatio(); });
        
        const folderInteraction = gui.addFolder('Interaction');
        folderInteraction.add(config, 'hoverRadius', 1, 10).name('Mouse Radius').onChange((v) => { material.uniforms.uHoverRadius.value = v; });
        folderInteraction.add(config, 'repelStrength', -5, 10).name('Force Strength').onChange((v) => { material.uniforms.uRepelStrength.value = v; });

        const folderBloom = gui.addFolder('Glow Effect');
        folderBloom.add(config, 'bloomStrength', 0, 3).onChange((v) => bloomPass.strength = v);
        folderBloom.add(config, 'bloomRadius', 0, 1).onChange((v) => bloomPass.radius = v);

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            const elapsedTime = clock.getElapsedTime();

            if (material) {
                material.uniforms.uTime.value = elapsedTime * config.speed;
            }

            controls.update();
            composer.render(); // Use composer instead of renderer for Bloom
            requestAnimationFrame(animate);
        }

        // --- RESIZE HANDLING ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if(material) material.uniforms.uSize.value = config.particleSize * renderer.getPixelRatio();
        });

        // Hide loader
        document.getElementById('loader').style.display = 'none';

        animate();
    </script>
</body>
</html>
