<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive 3D Christmas Landing Page</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #fullscreen-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            padding: 10px;
            background: rgba(255, 255, 255, 0.5);
            border: none;
            cursor: pointer;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <!-- Post-processing scripts from three.js examples -->
    <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
    <script src="https://threejs.org/examples/js/shaders/LuminosityHighPassShader.js"></script>
</head>
<body>
    <button id="fullscreen-btn">Fullscreen</button>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000022);
        scene.fog = new THREE.FogExp2(0x000022, 0.005);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 50, 300);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // Group for tree
        const group = new THREE.Group();
        scene.add(group);

        // Controls
        const controls = {
            treeColor: '#00ff00',
            snowDensity: 1.0,
            glowStrength: 1.2,
            animationSpeed: 1.0
        };

        const gui = new dat.GUI({ autoPlace: false });
        gui.domElement.style.position = 'absolute';
        gui.domElement.style.top = '50px';
        gui.domElement.style.right = '10px';
        document.body.appendChild(gui.domElement);

        gui.addColor(controls, 'treeColor').name('Tree Color').onChange(updateTreeColor);
        gui.add(controls, 'snowDensity', 0, 2).name('Snow Density').onChange(updateSnowDensity);
        gui.add(controls, 'glowStrength', 0, 3).name('Glow Strength').onChange(updateGlow);
        gui.add(controls, 'animationSpeed', 0, 2).name('Anim Speed');

        // Mouse tracking
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        let isHovering = false;
        let clickPosition = new THREE.Vector3();
        let particleScale = 1.0;

        // Tree particles
        let treeParticles;
        function createTreeParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];

            const levels = 20;
            const branchesPerLevel = 100;
            for (let level = 0; level < levels; level++) {
                const radius = (levels - level) * 5;
                const y = level * 10 - 100;
                for (let i = 0; i < branchesPerLevel; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
                    const z = Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
                    positions.push(x, y, z);
                    colors.push(0, 1, 0); // Green
                    sizes.push(1 + Math.random() * 2);
                }
            }

            // Trunk
            for (let i = 0; i < 500; i++) {
                const y = i * 0.4 - 100;
                const radius = 5 + Math.random() * 2;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                positions.push(x, y, z);
                colors.push(0.3, 0.1, 0); // Brown
                sizes.push(1);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    mousePos: { value: new THREE.Vector3() },
                    hover: { value: 0 },
                    speed: { value: 1.0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    uniform vec3 mousePos;
                    uniform float hover;
                    uniform float speed;

                    void main() {
                        vColor = color;
                        vec3 pos = position;
                        float dist = distance(pos, mousePos);
                        if (dist < 50.0) {
                            float force = (50.0 - dist) * 0.1;
                            vec3 dir = normalize(pos - mousePos);
                            pos += dir * force * (hover > 0.5 ? -1.0 : 1.0); // Repel on hover, attract otherwise
                            pos.x += sin(time * speed + pos.y) * force * 0.5; // Swirl
                            pos.z += cos(time * speed + pos.x) * force * 0.5;
                        }
                        pos += vec3(sin(time * speed * 0.1 + pos.y * 0.05) * 2.0, 0.0, cos(time * speed * 0.1 + pos.z * 0.05) * 2.0);
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
                        gl_FragColor = vec4(vColor, 1.0);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            treeParticles = new THREE.Points(geometry, material);
            group.add(treeParticles);
        }
        createTreeParticles();

        // Glowing lights on tree
        const lights = [];
        function createLights() {
            for (let i = 0; i < 50; i++) {
                const light = new THREE.PointLight(0xffaa00, 1, 100);
                light.position.set(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 200 - 100,
                    (Math.random() - 0.5) * 80
                );
                group.add(light);
                lights.push(light);

                // Glowing orb
                const sphere = new THREE.SphereGeometry(1, 16, 16);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00, emissive: 0xffaa00 });
                const mesh = new THREE.Mesh(sphere, mat);
                mesh.position.copy(light.position);
                group.add(mesh);
            }
        }
        createLights();

        // Snowfall
        let snowSystem;
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            const count = 5000 * controls.snowDensity;
            for (let i = 0; i < count; i++) {
                positions.push(Math.random() * 1000 - 500, Math.random() * 500, Math.random() * 1000 - 500);
                velocities.push(0, - (0.1 + Math.random() * 0.1), 0);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    speed: { value: 1.0 }
                },
                vertexShader: `
                    attribute vec3 velocity;
                    uniform float time;
                    uniform float speed;
                    void main() {
                        vec3 pos = position + velocity * time * speed;
                        if (pos.y < -250.0) pos.y += 500.0;
                        pos.x += sin(time * speed * 0.1 + pos.z) * 0.5; // Parallax sway
                        pos.z += cos(time * speed * 0.1 + pos.x) * 0.5;
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = 5.0 * (500.0 / -mvPosition.z); // Depth-based size
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    void main() {
                        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.5);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });

            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }
        createSnow();

        // Sparkle burst on click
        let sparkles = [];
        function createSparkleBurst(pos) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 100; i++) {
                positions.push(0, 0, 0);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const material = new THREE.PointsMaterial({
                color: Math.random() * 0xffffff,
                size: 2,
                blending: THREE.AdditiveBlending,
                transparent: true
            });

            const burst = new THREE.Points(geometry, material);
            burst.position.copy(pos);
            group.add(burst);

            sparkles.push({ mesh: burst, time: 0, positions: positions.map(() => new THREE.Vector3((Math.random() - 0.5)*2, (Math.random() - 0.5)*2, (Math.random() - 0.5)*2).normalize()) });

            setTimeout(() => {
                group.remove(burst);
                sparkles = sparkles.filter(s => s.mesh !== burst);
            }, 2000);
        }

        // Update functions
        function updateTreeColor(color) {
            const c = new THREE.Color(color);
            const colors = treeParticles.geometry.attributes.color.array;
            for (let i = 0; i < colors.length; i += 3) {
                if (colors[i + 1] > 0.5) { // Tree foliage
                    colors[i] = c.r;
                    colors[i + 1] = c.g;
                    colors[i + 2] = c.b;
                }
            }
            treeParticles.geometry.attributes.color.needsUpdate = true;
        }

        function updateSnowDensity() {
            scene.remove(snowSystem);
            createSnow();
        }

        function updateGlow(str) {
            bloomPass.strength = str;
        }

        // Event listeners
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (e.clientY / window.innerHeight) * 2 + 1;
        });

        document.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.1;
            particleScale += e.deltaY * 0.001;
            particleScale = Math.max(0.5, Math.min(2, particleScale));
            // Update sizes if needed
        });

        document.addEventListener('click', (e) => {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(treeParticles);
            if (intersects.length > 0) {
                createSparkleBurst(intersects[0].point);
            }
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime() * controls.animationSpeed;

            // Update tree shader
            treeParticles.material.uniforms.time.value = time;
            treeParticles.material.uniforms.speed.value = controls.animationSpeed;

            // Raycast for hover and mouse pos
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(treeParticles);
            isHovering = intersects.length > 0;
            treeParticles.material.uniforms.hover.value = isHovering ? 1.0 : 0.0;
            if (isHovering) {
                treeParticles.material.uniforms.mousePos.value.copy(intersects[0].point);
                bloomPass.strength = controls.glowStrength * 1.5; // Increase glow on hover
            } else {
                bloomPass.strength = controls.glowStrength;
            }

            // Update lights animation
            lights.forEach((light, i) => {
                light.intensity = 1 + Math.sin(time + i) * 0.5;
            });

            // Update snow
            snowSystem.material.uniforms.time.value = time;
            snowSystem.material.uniforms.speed.value = controls.animationSpeed;

            // Update sparkles
            sparkles.forEach(s => {
                s.time += 0.05;
                const posArray = s.mesh.geometry.attributes.position.array;
                for (let i = 0; i < posArray.length; i += 3) {
                    const dir = s.positions[i / 3];
                    posArray[i] = dir.x * s.time * 20;
                    posArray[i + 1] = dir.y * s.time * 20;
                    posArray[i + 2] = dir.z * s.time * 20;
                }
                s.mesh.geometry.attributes.position.needsUpdate = true;
                s.mesh.material.opacity = 1 - s.time;
            });

            // Rotate group slightly for motion
            group.rotation.y = Math.sin(time * 0.1) * 0.1;

            composer.render();
        }
        animate();
    </script>
</body>
</html>
