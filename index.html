<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particles - CodeWithAltin Style</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }
        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }
        .btn:hover, .btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instruction">Di chuyển CHUỘT (hoặc chạm tay trên màn hình) để tương tác với các hạt</div>

    <div id="ui-container">
        <button class="btn active" onclick="setShape('planet')">Hành Tinh</button>
        <button class="btn" onclick="setShape('sphere')">Khối Cầu</button>
        <button class="btn" onclick="setShape('galaxy')">Ngân Hà</button>
        <button class="btn" onclick="setShape('explosion')">Pháo Hoa</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

        // 1. Cấu hình cơ bản (Scene, Camera, Renderer)
        const scene = new THREE.Scene();
        // Hiệu ứng sương mù để tạo chiều sâu
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 2. Tạo Texture cho hạt (tạo bằng code để không cần load ảnh ngoài)
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 220, 100, 1)'); // Màu vàng kim
            gradient.addColorStop(0.4, 'rgba(255, 200, 50, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // 3. Hệ thống hạt (Particle System)
        const particleCount = 15000; // Số lượng hạt
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const targetPositions = []; // Vị trí đích để tạo hình
        const speeds = []; // Tốc độ di chuyển của từng hạt

        // Khởi tạo vị trí ngẫu nhiên ban đầu
        for (let i = 0; i < particleCount; i++) {
            positions.push((Math.random() - 0.5) * 400);
            positions.push((Math.random() - 0.5) * 400);
            positions.push((Math.random() - 0.5) * 400);
            
            targetPositions.push(0, 0, 0); // Placeholder
            speeds.push(Math.random() * 0.02 + 0.02);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('target', new THREE.Float32BufferAttribute(targetPositions, 3));

        const material = new THREE.PointsMaterial({
            size: 1.5,
            map: getTexture(),
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            vertexColors: false,
            color: 0xffddaa // Màu vàng nhạt tổng thể
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 4. Logic tạo hình dáng (Shapes)
        function calculateShapes(type) {
            const positionsAttribute = geometry.attributes.target;
            const count = particleCount;

            for (let i = 0; i < count; i++) {
                let x, y, z;

                if (type === 'sphere') {
                    // Hình cầu rỗng
                    const phi = Math.acos(-1 + (2 * i) / count);
                    const theta = Math.sqrt(count * Math.PI) * phi;
                    const r = 40;
                    
                    x = r * Math.cos(theta) * Math.sin(phi);
                    y = r * Math.sin(theta) * Math.sin(phi);
                    z = r * Math.cos(phi);

                } else if (type === 'planet') {
                    // Hình cầu + Vành đai (Giống video Saturn)
                    const r = 30;
                    if (i < count * 0.7) { // 70% hạt làm hành tinh
                        const phi = Math.acos(-1 + (2 * i) / (count * 0.7));
                        const theta = Math.sqrt((count * 0.7) * Math.PI) * phi;
                        
                        x = r * Math.cos(theta) * Math.sin(phi);
                        y = r * Math.sin(theta) * Math.sin(phi);
                        z = r * Math.cos(phi);
                    } else { // 30% hạt làm vành đai
                        const angle = i * 0.1;
                        const dist = 50 + Math.random() * 15;
                        x = Math.cos(angle) * dist;
                        y = (Math.random() - 0.5) * 2; // Độ dày vành đai mỏng
                        z = Math.sin(angle) * dist;
                        
                        // Nghiêng vành đai
                        const tilt = 0.5;
                        const oldY = y;
                        y = oldY * Math.cos(tilt) - z * Math.sin(tilt);
                        z = oldY * Math.sin(tilt) + z * Math.cos(tilt);
                    }

                } else if (type === 'galaxy') {
                    // Hình xoắn ốc
                    const angle = i * 0.05;
                    const r = i * 0.01; // Bán kính tăng dần
                    x = (r * 10) * Math.cos(angle);
                    y = (Math.random() - 0.5) * 10;
                    z = (r * 10) * Math.sin(angle);

                } else { // Explosion / Random
                    x = (Math.random() - 0.5) * 300;
                    y = (Math.random() - 0.5) * 300;
                    z = (Math.random() - 0.5) * 300;
                }

                positionsAttribute.setXYZ(i, x, y, z);
            }
            positionsAttribute.needsUpdate = true;
        }

        // Đặt hình dáng mặc định ban đầu
        calculateShapes('planet');

        // Hàm xử lý nút bấm
        window.setShape = (shapeName) => {
            calculateShapes(shapeName);
            // Cập nhật UI active
            document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        };

        // 5. Tương tác chuột (Raycaster & Mouse Plane)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(9999, 9999); // Để mặc định ở xa
        const mousePlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const mousePosition = new THREE.Vector3();

        document.addEventListener('mousemove', (event) => {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Tính toán vị trí chuột trong không gian 3D tại z=0 (hoặc gần camera)
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(mousePlane, mousePosition);
        });

        // Hỗ trợ cảm ứng trên điện thoại
        document.addEventListener('touchmove', (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(mousePlane, mousePosition);
        }, { passive: false });


        // 6. Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            const positionAttribute = geometry.attributes.position;
            const targetAttribute = geometry.attributes.target;

            // Quay nhẹ toàn bộ khối để tạo cảm giác 3D
            particles.rotation.y += 0.002;
            particles.rotation.z += 0.001;

            for (let i = 0; i < particleCount; i++) {
                // Lấy vị trí hiện tại
                let px = positionAttribute.getX(i);
                let py = positionAttribute.getY(i);
                let pz = positionAttribute.getZ(i);

                // Lấy vị trí đích (theo hình dáng đang chọn)
                const tx = targetAttribute.getX(i);
                const ty = targetAttribute.getY(i);
                const tz = targetAttribute.getZ(i);

                // Di chuyển hạt về vị trí đích (Easing)
                px += (tx - px) * speeds[i];
                py += (ty - py) * speeds[i];
                pz += (tz - pz) * speeds[i];

                // --- TƯƠNG TÁC CHUỘT (Mô phỏng Hand Tracking) ---
                // Chuyển đổi vị trí hạt sang tọa độ thế giới (do particles object bị xoay)
                const particleWorldPos = new THREE.Vector3(px, py, pz).applyMatrix4(particles.matrixWorld);
                
                // Tính khoảng cách từ hạt đến chuột
                const dx = mousePosition.x - particleWorldPos.x;
                const dy = mousePosition.y - particleWorldPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Nếu chuột ở gần (trong bán kính 25 đơn vị), đẩy hạt ra xa
                if (dist < 25) {
                    const force = (25 - dist) / 25; // Lực đẩy mạnh hơn khi càng gần
                    const angle = Math.atan2(dy, dx);
                    
                    // Đẩy ngược hướng chuột
                    const pushX = Math.cos(angle) * force * 50; 
                    const pushY = Math.sin(angle) * force * 50;

                    // Vì px, py là tọa độ cục bộ (local), ta cần trừ đi ảnh hưởng của rotation
                    // Để đơn giản hóa, ta cộng trực tiếp lực vào vị trí cục bộ (tạo hiệu ứng hỗn loạn đẹp mắt)
                    px -= pushX * 0.5;
                    py -= pushY * 0.5;
                }

                // Cập nhật lại vị trí
                positionAttribute.setXYZ(i, px, py, pz);
            }

            positionAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // Xử lý khi thay đổi kích thước màn hình
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
